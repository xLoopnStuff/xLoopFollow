name: 1. Validate Secrets
run-name: Validate Secrets (${{ github.ref_name }})
on: [workflow_call, workflow_dispatch]

jobs:
  validate-access-token:
    name: Access
    runs-on: macos-15
    env:
      GH_PAT: ${{ secrets.GH_PAT }}
      GH_TOKEN: ${{ secrets.GH_PAT }}
    outputs:
      HAS_WORKFLOW_PERMISSION: ${{ steps.access-token.outputs.has_workflow_permission }}
    steps:
      - name: Validate Access Token
        id: access-token
        run: |
          # Validate Access Token
          set -o pipefail
          GH_PAT_CLASSIC_PATTERN='^ghp_[a-zA-Z0-9]{36}$'
          GH_PAT_FINE_GRAINED_PATTERN='^github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59}$'

          if [ -z "$GH_PAT" ]; then
            failed=true
            echo "::error::The GH_PAT secret is unset or empty. Set it and try again."
          else
            if [[ $GH_PAT =~ $GH_PAT_CLASSIC_PATTERN ]]; then
              provides_scopes=true
              echo "The GH_PAT secret is a structurally valid classic token."
            elif [[ $GH_PAT =~ $GH_PAT_FINE_GRAINED_PATTERN ]]; then
              echo "The GH_PAT secret is a structurally valid fine-grained token."
            else
              unknown_format=true
              echo "The GH_PAT secret does not have a known token format."
            fi

            if ! scopes=$(curl -sS -f -I -H "Authorization: token $GH_PAT" https://api.github.com | { grep -i '^x-oauth-scopes:' || true; } | cut -d ' ' -f2- | tr -d '\r'); then
              failed=true
              if [ $unknown_format ]; then
                echo "::error::Unable to connect to GitHub using the GH_PAT secret. Verify that it is set correctly and try again."
              else
                echo "::error::Unable to connect to GitHub using the GH_PAT secret. Verify that the token exists and has not expired and try again."
              fi
            elif [[ $scopes =~ workflow ]]; then
              echo "The GH_PAT secret has repo and workflow permissions."
              echo "has_workflow_permission=true" >> $GITHUB_OUTPUT
            elif [[ $scopes =~ repo ]]; then
              echo "The GH_PAT secret has repo (but not workflow) permissions."
            elif [ $provides_scopes ]; then
              failed=true
              if [ -z "$scopes" ]; then
                echo "The GH_PAT secret is valid but returned no inspectable scopes."
              else
                echo "The GH_PAT secret is valid but only provides the following scopes: $scopes"
              fi
              echo "::error::The GH_PAT secret is lacking the 'repo' permission scope required for repository access."
            else
              echo "The GH_PAT secret is valid; assuming required scopes are present."
              echo "has_workflow_permission=true" >> $GITHUB_OUTPUT
            fi
          fi

          if [ $failed ]; then
            exit 2
          fi

  # ⬇️ Fjernet validate-match-secrets (den som lager Match-Secrets)

  validate-fastlane-secrets:
    name: Fastlane
    needs: [validate-access-token]   # <-- oppdatert, trenger ikke validate-match-secrets
    runs-on: macos-15
    env:
      GH_PAT: ${{ secrets.GH_PAT }}
      GH_TOKEN: ${{ secrets.GH_PAT }}
      FASTLANE_ISSUER_ID: ${{ secrets.FASTLANE_ISSUER_ID }}
      FASTLANE_KEY_ID: ${{ secrets.FASTLANE_KEY_ID }}
      FASTLANE_KEY: ${{ secrets.FASTLANE_KEY }}
      MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      TEAMID: ${{ secrets.TEAMID }}
      MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      # Sync the GitHub runner clock with the Windows time server (workaround as suggested in https://github.com/actions/runner/issues/2996)
      - name: Sync clock
        run: sudo sntp -sS time.windows.com

      - name: Validate Fastlane Secrets
        run: |
          # Validate Fastlane Secrets
          set -o pipefail

          # Validate TEAMID
          if [ -z "$TEAMID" ]; then
            failed=true
            echo "::error::The TEAMID secret is unset or empty. Set it and try again."
          elif [ ${#TEAMID} -ne 10 ] || ! [[ $TEAMID =~ ^[A-Z0-9]+$ ]]; then
            failed=true
            echo "::error::The TEAMID secret looks invalid."
          fi

          # Validate MATCH_PASSWORD
          if [ -z "$MATCH_PASSWORD" ]; then
            failed=true
            echo "::error::The MATCH_PASSWORD secret is unset or empty. Set it and try again."
          fi

          # Validate FASTLANE_ISSUER_ID, FASTLANE_KEY_ID, and FASTLANE_KEY
          FASTLANE_KEY_ID_PATTERN='^[A-Z0-9]+$'
          FASTLANE_ISSUER_ID_PATTERN='^\{?[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}\}?$'

          if [ -z "$FASTLANE_ISSUER_ID" ] || [ -z "$FASTLANE_KEY_ID" ] || [ -z "$FASTLANE_KEY" ]; then
            failed=true
            [ -z "$FASTLANE_ISSUER_ID" ] && echo "::error::FASTLANE_ISSUER_ID is missing."
            [ -z "$FASTLANE_KEY_ID"    ] && echo "::error::FASTLANE_KEY_ID is missing."
            [ -z "$FASTLANE_KEY"       ] && echo "::error::FASTLANE_KEY is missing."
          elif [ ${#FASTLANE_KEY_ID} -ne 10 ] || ! [[ $FASTLANE_KEY_ID =~ $FASTLANE_KEY_ID_PATTERN ]]; then
            failed=true
            echo "::error::FASTLANE_KEY_ID format is invalid."
          elif ! [[ $FASTLANE_ISSUER_ID =~ $FASTLANE_ISSUER_ID_PATTERN ]]; then
            failed=true
            echo "::error::FASTLANE_ISSUER_ID format is invalid."
          elif ! echo "$FASTLANE_KEY" | openssl pkcs8 -nocrypt >/dev/null 2>&1; then
            failed=true
            echo "::error::FASTLANE_KEY does not parse as PKCS#8. Paste the full .p8 contents."
          fi

          # Valgfritt: kalle fastlane-lane som verifiserer decrypt mot Match-Caregiver (Matchfile/Fastfile styrer repo og auth)
          if ! (bundle exec fastlane validate_secrets 2>&1 || true) | tee fastlane.log; then
            :
          fi

          if [ $failed ]; then
            exit 2
          fi
