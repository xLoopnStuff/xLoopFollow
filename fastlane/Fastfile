# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#     https://docs.fastlane.tools/actions
# For a list of all available plugins, check out
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

TEAMID = ENV["TEAMID"]
GH_PAT = ENV["GH_PAT"]
GITHUB_WORKSPACE = ENV["GITHUB_WORKSPACE"]
GITHUB_REPOSITORY_OWNER = ENV["GITHUB_REPOSITORY_OWNER"]
FASTLANE_KEY_ID = ENV["FASTLANE_KEY_ID"]
FASTLANE_ISSUER_ID = ENV["FASTLANE_ISSUER_ID"]
FASTLANE_KEY = ENV["FASTLANE_KEY"]
DEVICE_NAME = ENV["DEVICE_NAME"]
DEVICE_ID = ENV["DEVICE_ID"]
ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"

platform :ios do
  desc "Build Loop Follow"
  lane :build_LoopFollow do
    setup_ci if ENV['CI']

    update_project_team(
      path: "#{GITHUB_WORKSPACE}/LoopFollow.xcodeproj",
      teamid: TEAMID.to_s
    )

    api_key = app_store_connect_api_key(
      key_id: FASTLANE_KEY_ID.to_s,
      issuer_id: FASTLANE_ISSUER_ID.to_s,
      key_content: FASTLANE_KEY.to_s
    )

    # Hent siste TF buildnummer (fallback 0 om ingen finnes ennå)
    previous_build_number = 0
    begin
      previous_build_number = latest_testflight_build_number(
        app_identifier: "com.#{TEAMID}.loopkit.LoopFollow",
        api_key: api_key
      )
    rescue
      previous_build_number = 0
    end

    increment_build_number(
      xcodeproj: "#{GITHUB_WORKSPACE}/LoopFollow.xcodeproj",
      build_number: previous_build_number.to_i + 1
    )

    # Hent certs/profil fra Caregiver sitt Match-repo, uten å lage nye certs
    match(
      type: "appstore",
      app_identifier: ["com.#{TEAMID}.loopkit.LoopFollow"],
      # Bruk Matchfile sin git_url (Match-Caregiver) + denne auth-secret'en:
      git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'],
      readonly: false,                 # må kunne opprette/oppdatere provisioning-profil
      generate_apple_certs: false      # aldri lag nytt Distribution-sertifikat
    )

    mapping = Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]

    update_code_signing_settings(
      path: "#{GITHUB_WORKSPACE}/LoopFollow.xcodeproj",
      profile_name: mapping["com.#{TEAMID}.loopkit.LoopFollow"],
      code_sign_identity: "Apple Distribution",
      targets: ["LoopFollow"],
      use_automatic_signing: false
    )

    gym(
      export_method: "app-store",
      scheme: "LoopFollow",
      output_name: "LoopFollow.ipa",
      configuration: "Release",
      destination: 'generic/platform=iOS',
      buildlog_path: 'buildlog'
    )

    copy_artifacts(
      target_path: "artifacts",
      artifacts: ["*.mobileprovision", "*.ipa", "*.dSYM.zip"]
    )
  end

  desc "Push to TestFlight"
  lane :release do
    api_key = app_store_connect_api_key(
      key_id: FASTLANE_KEY_ID.to_s,
      issuer_id: FASTLANE_ISSUER_ID.to_s,
      key_content: FASTLANE_KEY.to_s
    )

    upload_to_testflight(
      api_key: api_key,
      skip_submission: false,
      ipa: "LoopFollow.ipa",
      skip_waiting_for_build_processing: true
    )
  end

  desc "Provision Identifiers and Certificates"
  lane :identifiers do
    setup_ci if ENV['CI']
    ENV["MATCH_READONLY"] = false.to_s

    app_store_connect_api_key(
      key_id: FASTLANE_KEY_ID.to_s,
      issuer_id: FASTLANE_ISSUER_ID.to_s,
      key_content: FASTLANE_KEY.to_s
    )

    def configure_bundle_id(name, identifier, capabilities)
      bundle_id = Spaceship::ConnectAPI::BundleId.find(identifier) ||
                  Spaceship::ConnectAPI::BundleId.create(
                    name:       name,
                    identifier: identifier,
                    platform:   "IOS"
                  )
      existing = bundle_id.get_capabilities.map(&:capability_type)
      capabilities.reject { |c| existing.include?(c) }.each { |cap| bundle_id.create_capability(cap) }
    end

    # Vær konsekvent med bundle id:
    configure_bundle_id("LoopFollow", "com.#{TEAMID}.loopkit.LoopFollow", [])
  end

  desc "Provision Certificates (henter fra Caregiver, lager ikke nye)"
  lane :certs do
    setup_ci if ENV['CI']
    ENV["MATCH_READONLY"] = false.to_s

    app_store_connect_api_key(
      key_id: FASTLANE_KEY_ID.to_s,
      issuer_id: FASTLANE_ISSUER_ID.to_s,
      key_content: FASTLANE_KEY.to_s
    )

    match(
      type: "appstore",
      app_identifier: ["com.#{TEAMID}.loopkit.LoopFollow"],
      git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'],
      readonly: false,
      generate_apple_certs: false
    )
  end

  desc "Validate Secrets"
  lane :validate_secrets do
    setup_ci if ENV['CI']
    ENV["MATCH_READONLY"] = true.to_s

    app_store_connect_api_key(
      key_id: FASTLANE_KEY_ID.to_s,
      issuer_id: FASTLANE_ISSUER_ID.to_s,
      key_content: FASTLANE_KEY.to_s
    )

    # Sjekk at riktig bundle id finnes (samme som ellers)
    Spaceship::ConnectAPI::BundleId.find("com.#{TEAMID}.loopkit.LoopFollow")

    match(
      type: "appstore",
      app_identifier: [],
      git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION'],
      readonly: true,
      generate_apple_certs: false
    )
  end

  desc "Nuke Certs (IKKE bruk uten at du vet hva du gjør)"
  lane :nuke_certs do
    setup_ci if ENV['CI']
    ENV["MATCH_READONLY"] = false.to_s

    app_store_connect_api_key(
      key_id: FASTLANE_KEY_ID.to_s,
      issuer_id: FASTLANE_ISSUER_ID.to_s,
      key_content: FASTLANE_KEY.to_s
    )

    match_nuke(
      type: "appstore",
      team_id: TEAMID.to_s,
      skip_confirmation: true,
      git_basic_authorization: ENV['MATCH_GIT_BASIC_AUTHORIZATION']
    )
  end

  desc "Check Certificates and Trigger Workflow for Expired or Missing Certificates"
  lane :check_and_renew_certificates do
    setup_ci if ENV['CI']
    ENV["MATCH_READONLY"] = false.to_s

    api_key = app_store_connect_api_key(
      key_id: ENV["FASTLANE_KEY_ID"],
      issuer_id: ENV["FASTLANE_ISSUER_ID"],
      key_content: ENV["FASTLANE_KEY"]
    )

    new_certificate_needed = false
    certificates = Spaceship::ConnectAPI::Certificate.all
    distribution_certs = certificates.select { |cert| cert.certificate_type == "DISTRIBUTION" }

    if distribution_certs.empty?
      puts "No Distribution certificates found! Triggering action to create certificate."
      new_certificate_needed = true
    else
      distribution_certs.each do |cert|
        expiration_date = Time.parse(cert.expiration_date)
        puts "Current Distribution Certificate: #{cert.id}, Expiration date: #{expiration_date}"
        new_certificate_needed = true if expiration_date < Time.now
      end
    end

    file_path = File.expand_path('new_certificate_needed.txt')
    File.write(file_path, new_certificate_needed ? 'true' : 'false')
    puts "\nAbsolute path of new_certificate_needed.txt: #{file_path}"
    puts "Certificate creation or renewal needed: #{File.read(file_path)}"
  end
end
